wekaClassification;	chooseClassifier(config); config; ; ; wekaCreateClassifier(config)


### CLASSIFIER CONSTRUCTION ###

# Weka General Method (single vs. meta vs. ensemble)
wekaBaseClassifier; 		wekaCreateClassifier(config); config,classifier,p; ; ; wekaCreateBaseClassifier(classifier) -> de.upb.crc901.mlplan.services.MLPipelinePlan:setClassifier(config, classifier, p)
wekaMetaClassifier; 		wekaCreateClassifier(config); config,classifier,p; ; ; wekaCreateMetaClassifier(classifier) -> de.upb.crc901.mlplan.services.MLPipelinePlan:setClassifier(config, classifier, p)
#wekaEnsembleClassifier;		wekaCreateClassifier(config); config,classifier,p; ; ; wekaCreateEnsembleClassifier(classifier) -> de.upb.crc901.mlplan.services.MLPipelinePlan:setClassifier(config, classifier, p)


### BASE CLASSIFIERS ###

# Bayes Network
#wekaBN;	wekaCreateBaseClassifier(c); c,oList,oArray; ; ; weka.classifiers.bayes.BayesNet:__construct(c) -> getOptionList(oList) -> getWekaBNConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.bayes.BayesNet:setOptions(c,oArray)
#wekaBN;	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ;;  assignTo('weka.classifiers.bayes.BayesNet',cn) -> getWekaBNConfig0(oList)
#wekaBN;	wekaSelectBaseClassifier(cn); cn; ; ; assignTo('weka.classifiers.bayes.BayesNet',cn)
wekaBN;	wekaParametrizeGivenBaseClassifier(cn,oList); cn,oList; assigned('weka.classifiers.bayes.BayesNet',cn) ;;  getWekaBNConfig0(oList)
# -D optional
wekaBNOptsUseADTree			; getWekaBNConfig0(o);	o; ; ; addOptParam(o, '-D') -> getWekaBNConfig1(o)
# -Q <proc> mandatory
wekaBNOptsSetLocalSearch	; getWekaBNConfig1(o);	o,proc; BNLocalSearch(proc) ; ; addMandatValuedParam(o, '-Q', proc)

# Naive Bayes
wekaNB;	wekaCreateBaseClassifier(c); c,oList,oArray; ;	; weka.classifiers.bayes.NaiveBayes:__construct(c) -> getOptionList(oList) -> getWekaNBConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.bayes.NaiveBayes:setOptions(c,oArray)
wekaNB;	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ;;  assignTo('weka.classifiers.bayes.NaiveBayes',cn) -> getWekaNBConfig0(oList)
wekaNB;	wekaSelectBaseClassifier(cn); cn; ;;  assignTo('weka.classifiers.bayes.NaiveBayes',cn)
wekaNB;	wekaParametrizeGivenBaseClassifier(cn,oList); cn,oList; assigned('weka.classifiers.bayes.NaiveBayes',cn) ; ; getWekaNBConfig0(oList)
# -D, -K optional, -D or -K, not both
wekaNBOptsUseKernelEst		; getWekaNBConfig0(o);	o; ; ; addOptParam(o, '-D') -> getWekaNBConfig1(o)
wekaNBOptsUseSupervisedDisc	; getWekaNBConfig1(o);	o; in(o,'-D') ; ; noop
wekaNBOptsUseSupervisedDisc	; getWekaNBConfig1(o);	o; notin(o,'-D') ; ; addOptParam(o, '-K')

# Naive Bayes Multinomial
#wekaNBMN;	wekaCreateRawBaseClassifier(cn,c); cn,c; ;	weka.classifiers.bayes.NaiveBayesMultinomial:__construct(c) -> assignTo('weka.classifiers.bayes.NaiveBayesMultinomial',cn)
#wekaNBMN;	wekaCreateGivenBaseClassifier(c); c,oList,oArray; assigned('weka.classifiers.bayes.NaiveBayesMultinomial',cn) ;	weka.classifiers.bayes.NaiveBayesMultinomial:__construct(c) -> getOptionList(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.bayes.NaiveBayesMultinomial:setOptions(c,oArray)
wekaNBMN;	wekaCreateBaseClassifier(c); c,oList,oArray; ;	; weka.classifiers.bayes.NaiveBayesMultinomial:__construct(c) -> getOptionList(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.bayes.NaiveBayesMultinomial:setOptions(c,oArray)
wekaNBMN;	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; ; assignTo('weka.classifiers.bayes.NaiveBayesMultinomial',cn)
wekaNBMN;	wekaSelectBaseClassifier(cn); cn; ; ;  assignTo('weka.classifiers.bayes.NaiveBayesMultinomial',cn)
wekaNBMN;	wekaParametrizeGivenBaseClassifier(cn,oList); cn,oList; assigned('weka.classifiers.bayes.NaiveBayesMultinomial',cn) ; ; noop
# No parameter

# Gaussian Processess
#wekaGP;	wekaCreateRawBaseClassifier(cn,c); cn,c; ;	weka.classifiers.functions.GaussianProcesses:__construct(c) -> assignTo('weka.classifiers.functions.GaussianProcesses',cn)
#wekaGP;	wekaCreateGivenBaseClassifier(cn,c); cn,c,oList,oArray; assigned('weka.classifiers.functions.GaussianProcesses',cn) ;	weka.classifiers.functions.GaussianProcesses:__construct(c) -> getOptionList(oList) -> getWekaGPConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.functions.GaussianProcesses:setOptions(c,oArray)
#wekaGP;	wekaCreateBaseClassifier(c); c,oList,oArray; ;	; weka.classifiers.functions.GaussianProcesses:__construct(c) -> getOptionList(oList) -> getWekaGPConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.functions.GaussianProcesses:setOptions(c,oArray)
#wekaGP;	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; ; assignTo('weka.classifiers.functions.GaussianProcesses',cn) -> getWekaGPConfig0(oList)
wekaGP;	wekaSelectBaseClassifier(cn); cn; ; ; assignTo('weka.classifiers.functions.GaussianProcesses',cn)
wekaGP;	wekaParametrizeGivenBaseClassifier(cn,oList); cn,oList; assigned('weka.classifiers.functions.GaussianProcesses',cn) ; ; getWekaGPConfig0(oList)
# -L <float>, -N <int> mandatory
wekaGPOptsTolerance		; getWekaGPConfig0(o);	o,float; GPTolerance(float) ; ; addMandatValuedParam(o, '-L', float) -> getWekaGPConfig1(o)
wekaGPOptsFilterType	; getWekaGPConfig1(o);	o,int; GPFilterType(int) ; ;  addMandatValuedParam(o, '-N', int) -> getWekaGPConfig2(o)
# -K <class> mandatory
wekaGPOptsKernel		; getWekaGPConfig2(o);	o,name,oLocal,param; Kernel(name) ; ; getOptionList(oLocal) -> addMandatParam(oLocal,name) -> getWekaGPLocalConfig0(oLocal) -> concatenate(oLocal,param) -> addMandatValuedParam(o, '-K', param)
# Kernel weka.classifiers.functions.supportVector.NormalizedPolyKernel
# -E <float> mandatory
wekaGPOptsKernelNpolyE	; getWekaGPLocalConfig0(o); o,float; in(o,'weka.classifiers.functions.supportVector.NormalizedPolyKernel') & PolyKernelExponent(float) ; ; addMandatValuedParam(o, '-E', float) -> getWekaGPLocalConfig1(o)
# -L optional
wekaGPOptsKernelNpolyL	; getWekaGPLocalConfig1(o); o; in(o,'weka.classifiers.functions.supportVector.NormalizedPolyKernel') ; ; addOptParam(o, '-L')
# Kernel weka.classifiers.functions.supportVector.PolyKernel
# -E <float> mandatory
wekaGPOptsKernelPolyE	; getWekaGPLocalConfig0(o); o,float; in(o,'weka.classifiers.functions.supportVector.PolyKernel') & PolyKernelExponent(float) ; ; addMandatValuedParam(o, '-E', float) -> getWekaGPLocalConfig1(o)
# -L optional
wekaGPOptsKernelPolyL	; getWekaGPLocalConfig1(o); o; in(o,'weka.classifiers.functions.supportVector.PolyKernel') ; ; addOptParam(o, '-L')
# Kernel weka.classifiers.functions.supportVector.Puk
# -S <float>, -O <float> mandatory
wekaGPOptsKernelPukS	; getWekaGPLocalConfig0(o); o,float; in(o,'weka.classifiers.functions.supportVector.Puk') & PukKernelSigma(float) ; ; addMandatValuedParam(o, '-S', float) -> getWekaGPLocalConfig1(o)
wekaGPOptsKernelPukO	; getWekaGPLocalConfig1(o); o,float; in(o,'weka.classifiers.functions.supportVector.Puk') & PukKernelOmega(float) ; ; addMandatValuedParam(o, '-O', float)
# Kernel weka.classifiers.functions.supportVector.RBFKernel
# -G <float> mandatory
wekaGPOptsKernelRBFS	; getWekaGPLocalConfig0(o); o,float; in(o,'weka.classifiers.functions.supportVector.RBFKernel') & RBFKernelGamma(float) ; ; addMandatValuedParam(o, '-G', float)

###### TODO: no.uib.cipr.matrix.MatrixNotSPDException for some data sets.

# Linear Regression
#wekaLinearR;	wekaCreateRawBaseClassifier(cn,c); cn,c; ;	weka.classifiers.functions.LinearRegression:__construct(c) -> assignTo('weka.classifiers.functions.LinearRegression',cn)
#wekaLinearR;	wekaCreateGivenBaseClassifier(cn,c); cn,c,oList,oArray; assigned('weka.classifiers.functions.LinearRegression',cn) ;	weka.classifiers.functions.LinearRegression:__construct(c) -> getOptionList(oList) -> getWekaLinearRConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.functions.LinearRegression:setOptions(c,oArray)
#wekaLinearR;	wekaCreateBaseClassifier(c); c,oList,oArray; ;	; weka.classifiers.functions.LinearRegression:__construct(c) -> getOptionList(oList) -> getWekaLinearRConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.functions.LinearRegression:setOptions(c,oArray)
#wekaLinearR;	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; ; assignTo('weka.classifiers.functions.LinearRegression',cn) -> getWekaLinearRConfig0(oList)
wekaLinearR;	wekaSelectBaseClassifier(cn); cn; ; ; assignTo('weka.classifiers.functions.LinearRegression',cn)
wekaLinearR;	wekaParametrizeGivenBaseClassifier(cn,oList); cn,oList; assigned('weka.classifiers.functions.LinearRegression',cn) ; ; getWekaLinearRConfig0(oList)
# -C optional
wekaLinearROptsCollinAttr		; getWekaLinearRConfig0(o);	o; ; ; addOptParam(o, '-C') -> getWekaLinearRConfig1(o)
# -R <float>, -S <type> mandatory
wekaLinearROptsRidge			; getWekaLinearRConfig1(o);	o,float; LinearRRidge(float) ; ; addMandatValuedParam(o, '-R', float) -> getWekaLinearRConfig2(o)
wekaLinearROptsAttrSel			; getWekaLinearRConfig2(o);	o,type; LinearRAttrSel(type) ; ;  addMandatValuedParam(o, '-S', type)

# Logistic Regression
#wekaLR;	wekaCreateRawBaseClassifier(cn,c); cn,c; ;	weka.classifiers.functions.Logistic:__construct(c) -> assignTo('weka.classifiers.functions.Logistic',cn)
#wekaLR;	wekaCreateGivenBaseClassifier(cn,c); cn,c,oList,oArray; assigned('weka.classifiers.functions.Logistic',cn) ;	weka.classifiers.functions.Logistic:__construct(c) -> getOptionList(oList) -> getWekaLogisticRConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.functions.Logistic:setOptions(c,oArray)
wekaLR;	wekaCreateBaseClassifier(c); c,oList,oArray; ;	; weka.classifiers.functions.Logistic:__construct(c) -> getOptionList(oList) -> getWekaLogisticRConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.functions.Logistic:setOptions(c,oArray)
wekaLR;	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ;;  assignTo('weka.classifiers.functions.Logistic',cn) -> getWekaLogisticRConfig0(oList)
wekaLR;	wekaSelectBaseClassifier(cn); cn; ; ; assignTo('weka.classifiers.functions.Logistic',cn)
wekaLR;	wekaParametrizeGivenBaseClassifier(cn,oList); cn,oList; assigned('weka.classifiers.functions.Logistic',cn) ; ; getWekaLogisticRConfig0(oList)
# -R <float> mandatory
wekaLogisticROptsRidge			; getWekaLogisticRConfig0(o);	o,float; LogisticRRidge(float) ; ; addMandatValuedParam(o, '-R', float)

# Neural Networks
#wekaNN;	wekaCreateRawBaseClassifier(cn,c); cn,c; ;	weka.classifiers.functions.MultilayerPerceptron:__construct(c) -> assignTo('weka.classifiers.functions.MultilayerPerceptron',cn)
#wekaNN;	wekaCreateGivenBaseClassifier(cn,c); cn,c,oList,oArray; assigned('weka.classifiers.functions.MultilayerPerceptron',cn) ;	weka.classifiers.functions.MultilayerPerceptron:__construct(c) -> getOptionList(oList) -> getWekaNNConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.functions.MultilayerPerceptron:setOptions(c,oArray)
wekaNN;	wekaCreateBaseClassifier(c); c,oList,oArray; ;	; weka.classifiers.functions.MultilayerPerceptron:__construct(c) -> getOptionList(oList) -> getWekaNNConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.functions.MultilayerPerceptron:setOptions(c,oArray)
wekaNN;	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; ; assignTo('weka.classifiers.functions.MultilayerPerceptron',cn) -> getWekaNNConfig0(oList)
wekaNN;	wekaSelectBaseClassifier(cn); cn; ;;  assignTo('weka.classifiers.functions.MultilayerPerceptron',cn)
wekaNN;	wekaParametrizeGivenBaseClassifier(cn,oList); cn,oList; assigned('weka.classifiers.functions.MultilayerPerceptron',cn) ;;  getWekaNNConfig0(oList)
# -B, -C, -D, -R optional
wekaNNOptsN2BFilter		; getWekaNNConfig0(o);	o; ;;  addOptParam(o, '-B') -> getWekaNNConfig1(o)
wekaNNOptsNormNumClass	; getWekaNNConfig1(o);	o; ;;  addOptParam(o, '-C') -> getWekaNNConfig2(o)
wekaNNOptsDecay			; getWekaNNConfig2(o);	o; ;;  addOptParam(o, '-D') -> getWekaNNConfig3(o)
wekaNNOptsReset			; getWekaNNConfig3(o);	o; ;;  addOptParam(o, '-R') -> getWekaNNConfig4(o)
# -H <type>, -L <float>, -M <float>, -S <1> mandatory
wekaNNOptsHiddenLayers	; getWekaNNConfig4(o);	o,type; NNHiddenLayer(type) ;;  addMandatValuedParam(o, '-H', type) -> getWekaNNConfig5(o)
wekaNNOptsLearningRate	; getWekaNNConfig5(o);	o,float; NNLearningRate(float) ;;  addMandatValuedParam(o, '-L', float) -> getWekaNNConfig6(o)
wekaNNOptsMomentum		; getWekaNNConfig6(o);	o,float; NNMomentum(float) ;;  addMandatValuedParam(o, '-M', float) -> getWekaNNConfig7(o)
wekaNNOptsSeed			; getWekaNNConfig7(o);	o; ;;  addMandatValuedParam(o, '-S', '1')

# SGD
#wekaSGDs;	wekaCreateRawBaseClassifier(cn,c); cn,c; ; weka.classifiers.functions.SGD:__construct(c) -> assignTo('weka.classifiers.functions.SGD',cn)
#wekaSGDs;	wekaCreateGivenBaseClassifier(cn,c); cn,c,oList,oArray; assigned('weka.classifiers.functions.SGD',cn) ; weka.classifiers.functions.SGD:__construct(c) -> getOptionList(oList) -> getWekaSGDConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.functions.SGD:setOptions(c,oArray)
wekaSGDs;	wekaCreateBaseClassifier(c); c,oList,oArray; ;;  weka.classifiers.functions.SGD:__construct(c) -> getOptionList(oList) -> getWekaSGDConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.functions.SGD:setOptions(c,oArray)
wekaSGDs;	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ;;  assignTo('weka.classifiers.functions.SGD',cn) -> getWekaSGDConfig0(oList)
wekaSGDs;	wekaSelectBaseClassifier(cn); cn; ;;  assignTo('weka.classifiers.functions.SGD',cn)
wekaSGDs;	wekaParametrizeGivenBaseClassifier(cn,oList); cn,oList; assigned('weka.classifiers.functions.SGD',cn) ;;  getWekaSGDConfig0(oList)
# -M, -N optional
wekaSGDOptsReplaceMiss	; getWekaSGDConfig0(o);	o; ;;  addOptParam(o, '-M') -> getWekaSGDConfig1(o)
wekaSGDOptsNormalize	; getWekaSGDConfig1(o);	o; ;;  addOptParam(o, '-N') -> getWekaSGDConfig2(o)
# -F <type>, -L <float>, -R <float> mandatory
wekaSGDOptsLossFunc		; getWekaSGDConfig2(o);	o,type; SGDLossFunction(type) ;;  addMandatValuedParam(o, '-F', type) -> getWekaSGDConfig3(o)
wekaSGDOptsLearningRate	; getWekaSGDConfig3(o);	o,float; SGDLearningRate(float) ;;  addMandatValuedParam(o, '-L', float) -> getWekaSGDConfig4(o)
wekaSGDOptsLambda		; getWekaSGDConfig4(o);	o,float; SGDLambda(float) ;;  addMandatValuedParam(o, '-R', float)

# SVM
####### wekaSVMs;	wekaCreateBaseClassifier(c); c,oList,oArray; ; weka.classifiers.functions.LibSVM:__construct(c) -> getOptionList(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.functions.LibSVM:setOptions(c,oArray)
####### wekaSVMs;	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; assignTo('weka.classifiers.functions.LibSVM',cn)
# TODO

# Simple Linear Regression
#wekaSimpleLinearReg; wekaCreateRawBaseClassifier(cn,c); cn,c; ;	weka.classifiers.functions.SimpleLinearRegression:__construct(c) -> assignTo('weka.classifiers.functions.SimpleLinearRegression',cn)
#wekaSimpleLinearReg; wekaCreateGivenBaseClassifier(cn,c); cn,c,oList,oArray; assigned('weka.classifiers.functions.SimpleLinearRegression',cn) ;	weka.classifiers.functions.SimpleLinearRegression:__construct(c) -> getOptionList(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.functions.SimpleLinearRegression:setOptions(c,oArray)
wekaSimpleLinearReg; wekaCreateBaseClassifier(c); c,oList,oArray; ;; 	weka.classifiers.functions.SimpleLinearRegression:__construct(c) -> getOptionList(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.functions.SimpleLinearRegression:setOptions(c,oArray)
wekaSimpleLinearReg; wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; ; assignTo('weka.classifiers.functions.SimpleLinearRegression',cn)
wekaSimpleLinearReg; wekaSelectBaseClassifier(cn); cn; ;;  assignTo('weka.classifiers.functions.SimpleLinearRegression',cn)
wekaSimpleLinearReg; wekaParametrizeGivenBaseClassifier(cn,oList); cn,oList; assigned('weka.classifiers.functions.SimpleLinearRegression',cn) ; ; noop
# No parameters

# Simple Logistic Regression
#wekaSimpleLogisticReg;	wekaCreateRawBaseClassifier(cn,c); cn,c; ; weka.classifiers.functions.SimpleLogistic:__construct(c) -> assignTo('weka.classifiers.functions.SimpleLogistic',cn)
#wekaSimpleLogisticReg;	wekaCreateGivenBaseClassifier(cn,c); cn,c,oList,oArray; assigned('weka.classifiers.functions.SimpleLogistic',cn) ; weka.classifiers.functions.SimpleLogistic:__construct(c) -> getOptionList(oList) -> getWekaSimpleLogRegConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.functions.SimpleLogistic:setOptions(c,oArray)
wekaSimpleLogisticReg;	wekaCreateBaseClassifier(c); c,oList,oArray; ; ; weka.classifiers.functions.SimpleLogistic:__construct(c) -> getOptionList(oList) -> getWekaSimpleLogRegConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.functions.SimpleLogistic:setOptions(c,oArray)
wekaSimpleLogisticReg;	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; ; assignTo('weka.classifiers.functions.SimpleLogistic',cn) -> getWekaSimpleLogRegConfig0(oList)
wekaSimpleLogisticReg;	wekaSelectBaseClassifier(cn); cn; ; ; assignTo('weka.classifiers.functions.SimpleLogistic',cn)
wekaSimpleLogisticReg;	wekaParametrizeGivenBaseClassifier(cn,oList); cn,oList; assigned('weka.classifiers.functions.SimpleLogistic',cn) ; ; getWekaSimpleLogRegConfig0(oList)
# -A, -S optional
wekaSimpleLogRegOptsAIC			; getWekaSimpleLogRegConfig0(o);	o; ; ; addOptParam(o, '-A') -> getWekaSimpleLogRegConfig1(o)
wekaSimpleLogRegOptsCrossVal	; getWekaSimpleLogRegConfig1(o);	o; ; ; addOptParam(o, '-S') -> getWekaSimpleLogRegConfig2(o)
# -W <float> mandatory, value 0 for unused
wekaSimpleLogRegOptsWeightTrim			; getWekaSimpleLogRegConfig2(o);	o; ; ; addMandatValuedParam(o, '-W', '0')
wekaSimpleLogRegOptsWeightTrim			; getWekaSimpleLogRegConfig2(o);	o,float; SLROptsWeightTrim(float) ; ; addMandatValuedParam(o, '-W', float)

# SMO
#wekaSMO;	wekaCreateRawBaseClassifier(cn,c); cn,c; ; weka.classifiers.functions.SMO:__construct(c) -> assignTo('weka.classifiers.functions.SMO',cn)
#wekaSMO;	wekaCreateGivenBaseClassifier(cn,c); cn,c,oList,oArray; assigned('weka.classifiers.functions.SMO',cn) ; weka.classifiers.functions.SMO:__construct(c) -> getOptionList(oList) -> getWekaSMOConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.functions.SMO:setOptions(c,oArray)
wekaSMO;	wekaCreateBaseClassifier(c); c,oList,oArray; ; ; weka.classifiers.functions.SMO:__construct(c) -> getOptionList(oList) -> getWekaSMOConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.functions.SMO:setOptions(c,oArray)
wekaSMO;	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; ; assignTo('weka.classifiers.functions.SMO',cn) -> getWekaSMOConfig0(oList)
wekaSMO;	wekaSelectBaseClassifier(cn); cn; ; ; assignTo('weka.classifiers.functions.SMO',cn)
wekaSMO;	wekaParametrizeGivenBaseClassifier(cn,oList); cn,oList; assigned('weka.classifiers.functions.SMO',cn) ; ; getWekaSMOConfig0(oList)
# -C <float>, -N <int> mandatory
wekaSMOOptsComplexity	; getWekaSMOConfig0(o);	o,float; SMOComplexity(float) ; ; addMandatValuedParam(o, '-C', float) -> getWekaSMOConfig1(o)
wekaSMOOptsFilter		; getWekaSMOConfig1(o);	o,int; SMOFilterType(int) ; ; addMandatValuedParam(o, '-N', int) -> getWekaSMOConfig2(o)
# -M optional
wekaSMOBuildCalibrationModels	; getWekaSMOConfig2(o);	o; ; ; addOptParam(o, '-M') -> getWekaSMOConfig3(o)
# -K <class> mandatory
wekaSMOOptsKernel		; getWekaSMOConfig3(o);	o,name,oLocal,param; Kernel(name) ; ; getOptionList(oLocal) -> addMandatParam(oLocal,name) -> getWekaSMOLocalConfig0(oLocal) -> concatenate(oLocal,param) -> addMandatValuedParam(o, '-K', param)
# Kernel weka.classifiers.functions.supportVector.NormalizedPolyKernel
# -E <float> mandatory
wekaSMOOptsKernelNpolyE	; getWekaSMOLocalConfig0(o); o,float; in(o,'weka.classifiers.functions.supportVector.NormalizedPolyKernel') & PolyKernelExponent(float) ; ; addMandatValuedParam(o, '-E', float) -> getWekaSMOLocalConfig1(o)
# -L optional
wekaSMOOptsKernelNpolyL	; getWekaSMOLocalConfig1(o); o; in(o,'weka.classifiers.functions.supportVector.NormalizedPolyKernel') ; ; addOptParam(o, '-L')
# Kernel weka.classifiers.functions.supportVector.PolyKernel
# -E <float> mandatory
wekaSMOOptsKernelPolyE	; getWekaSMOLocalConfig0(o); o,float; in(o,'weka.classifiers.functions.supportVector.PolyKernel') & PolyKernelExponent(float) ; ; addMandatValuedParam(o, '-E', float) -> getWekaSMOLocalConfig1(o)
# -L optional
wekaSMOOptsKernelPolyL	; getWekaSMOLocalConfig1(o); o; in(o,'weka.classifiers.functions.supportVector.PolyKernel') ; ; addOptParam(o, '-L')
# Kernel weka.classifiers.functions.supportVector.Puk
# -S <float>, -O <float> mandatory
wekaSMOOptsKernelPukS	; getWekaSMOLocalConfig0(o); o,float; in(o,'weka.classifiers.functions.supportVector.Puk') & PukKernelSigma(float) ; ; addMandatValuedParam(o, '-S', float) -> getWekaSMOLocalConfig1(o)
wekaSMOOptsKernelPukO	; getWekaSMOLocalConfig1(o); o,float; in(o,'weka.classifiers.functions.supportVector.Puk') & PukKernelOmega(float) ; ; addMandatValuedParam(o, '-O', float)
# Kernel weka.classifiers.functions.supportVector.RBFKernel
# -G <float> mandatory
wekaSMOOptsKernelRBFS	; getWekaSMOLocalConfig0(o); o,float; in(o,'weka.classifiers.functions.supportVector.RBFKernel') & RBFKernelGamma(float) ; ;  addMandatValuedParam(o, '-G', float)

# SMOreg
#wekaSMOreg;	wekaCreateRawBaseClassifier(cn,c); cn,c; ; weka.classifiers.functions.SMOreg:__construct(c) -> assignTo('weka.classifiers.functions.SMOreg',cn)
#wekaSMOreg;	wekaCreateGivenBaseClassifier(cn,c); cn,c,oList,oArray; assigned('weka.classifiers.functions.SMOreg',cn) ; weka.classifiers.functions.SMOreg:__construct(c) -> getOptionList(oList) -> getWekaSMOregConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.functions.SMOreg:setOptions(c,oArray)
#wekaSMOreg;	wekaCreateBaseClassifier(c); c,oList,oArray; ; ; weka.classifiers.functions.SMOreg:__construct(c) -> getOptionList(oList) -> getWekaSMOregConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.functions.SMOreg:setOptions(c,oArray)
#wekaSMOreg;	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; ; assignTo('weka.classifiers.functions.SMOreg',cn) -> getWekaSMOregConfig0(oList)
wekaSMOreg;	wekaSelectBaseClassifier(cn); cn; ; ;  assignTo('weka.classifiers.functions.SMOreg',cn)
wekaSMOreg;	wekaParametrizeGivenBaseClassifier(cn,oList); cn,oList; assigned('weka.classifiers.functions.SMOreg',cn) ; ;  getWekaSMOregConfig0(oList)
# -C <float> mandatory
wekaSMOregOptsComplexity	; getWekaSMOregConfig0(o);	o,float; SMOComplexity(float) ; ;  addMandatValuedParam(o, '-C', float) -> getWekaSMOregConfig1(o)
# -N <int> mandatory
wekaSMOregOptsFilter		; getWekaSMOregConfig1(o);	o,int; SMOFilterType(int) ; ;  addMandatValuedParam(o, '-N', int) -> getWekaSMOregConfig2(o)
# -I <class> mandatory
wekaSMOregOptsRegOptimizer	; getWekaSMOregConfig2(o);	o,name,oLocal,param; RegOptimizer(name) ; ;  getOptionList(oLocal) -> addMandatParam(oLocal,name) -> getWekaSMOregLocalConfig0(oLocal) -> concatenate(oLocal,param) -> addMandatValuedParam(o, '-I', param) -> getWekaSMOregConfig3(o)
# RegOptimizer weka.classifiers.functions.supportVector.RegSMOImproved
# -V optional
wekaSMOregUseVariant		; getWekaSMOregLocalConfig0(o); o; in(o,'weka.classifiers.functions.supportVector.RegSMOImproved') ; ; addOptParam(o, '-V')
# -K <class> mandatory
wekaSMOregOptsKernel		; getWekaSMOregConfig3(o);	o,name,oLocal,param; Kernel(name) ; ;  getOptionList(oLocal) -> addMandatParam(oLocal,name) -> getWekaSMOregLocalConfig0(oLocal) -> concatenate(oLocal,param) -> addMandatValuedParam(o, '-K', param)
# Kernel weka.classifiers.functions.supportVector.NormalizedPolyKernel
# -E <float> mandatory
wekaSMOregOptsKernelNpolyE	; getWekaSMOregLocalConfig0(o); o,float; in(o,'weka.classifiers.functions.supportVector.NormalizedPolyKernel') & PolyKernelExponent(float) ; ; addMandatValuedParam(o, '-E', float) -> getWekaSMOregLocalConfig1(o)
# -L optional
wekaSMOregOptsKernelNpolyL	; getWekaSMOregLocalConfig1(o); o; in(o,'weka.classifiers.functions.supportVector.NormalizedPolyKernel') ; ; addOptParam(o, '-L')
# Kernel weka.classifiers.functions.supportVector.PolyKernel
# -E <float> mandatory
wekaSMOregOptsKernelPolyE	; getWekaSMOregLocalConfig0(o); o,float; in(o,'weka.classifiers.functions.supportVector.PolyKernel') & PolyKernelExponent(float) ; ; addMandatValuedParam(o, '-E', float) -> getWekaSMOregLocalConfig1(o)
# -L optional
wekaSMOregOptsKernelPolyL	; getWekaSMOregLocalConfig1(o); o; in(o,'weka.classifiers.functions.supportVector.PolyKernel') ; ; addOptParam(o, '-L')
# Kernel weka.classifiers.functions.supportVector.Puk
# -S <float>, -O <float> mandatory
wekaSMOregOptsKernelPukS	; getWekaSMOregLocalConfig0(o); o,float; in(o,'weka.classifiers.functions.supportVector.Puk') & PukKernelSigma(float) ; ; addMandatValuedParam(o, '-S', float) -> getWekaSMOregLocalConfig1(o)
wekaSMOregOptsKernelPukO	; getWekaSMOregLocalConfig1(o); o,float; in(o,'weka.classifiers.functions.supportVector.Puk') & PukKernelOmega(float) ; ; addMandatValuedParam(o, '-O', float)
# Kernel weka.classifiers.functions.supportVector.RBFKernel
# -G <float> mandatory
wekaSMOregOptsKernelRBFS	; getWekaSMOregLocalConfig0(o); o,float; in(o,'weka.classifiers.functions.supportVector.RBFKernel') & RBFKernelGamma(float) ; ; addMandatValuedParam(o, '-G', float)

# Voted Perceptrons
#wekaVotedPerceptrons;	wekaCreateRawBaseClassifier(cn,c); cn,c; ; weka.classifiers.functions.VotedPerceptron:__construct(c) -> assignTo('weka.classifiers.functions.VotedPerceptron',cn)
#wekaVotedPerceptrons;	wekaCreateGivenBaseClassifier(cn,c); cn,c,oList,oArray; assigned('weka.classifiers.functions.VotedPerceptron',cn) ; weka.classifiers.functions.VotedPerceptron:__construct(c) -> getOptionList(oList) -> getWekaVPConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.functions.VotedPerceptron:setOptions(c,oArray)
wekaVotedPerceptrons;	wekaCreateBaseClassifier(c); c,oList,oArray; ; ;  weka.classifiers.functions.VotedPerceptron:__construct(c) -> getOptionList(oList) -> getWekaVPConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.functions.VotedPerceptron:setOptions(c,oArray)
wekaVotedPerceptrons;	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; ; assignTo('weka.classifiers.functions.VotedPerceptron',cn) -> getWekaVPConfig0(oList)
wekaVotedPerceptrons;	wekaSelectBaseClassifier(cn); cn; ; ; assignTo('weka.classifiers.functions.VotedPerceptron',cn)
wekaVotedPerceptrons;	wekaParametrizeGivenBaseClassifier(cn,oList); cn,oList; assigned('weka.classifiers.functions.VotedPerceptron',cn) ; ;  getWekaVPConfig0(oList)
# -E <float>, -I <int>, -M <int> mandatory
wekaVPOptsExponent		; getWekaVPConfig0(o);	o,float; VPExponent(float) ; ; addMandatValuedParam(o, '-E', float) -> getWekaVPConfig1(o)
wekaVPOptsIterations	; getWekaVPConfig1(o);	o,int; VPIterations(int) ; ; addMandatValuedParam(o, '-I', int) -> getWekaVPConfig2(o)
wekaVPOptsMaxK			; getWekaVPConfig2(o);	o,int; VPMaxK(int) ; ; addMandatValuedParam(o, '-M', int)

# KNN
#wekaKNN;	wekaCreateRawBaseClassifier(cn,c); cn,c; ; weka.classifiers.lazy.IBk:__construct(c) -> assignTo('weka.classifiers.lazy.IBk',cn)
#wekaKNN;	wekaCreateGivenBaseClassifier(cn,c); cn,c,oList,oArray; assigned('weka.classifiers.lazy.IBk',cn) ; weka.classifiers.lazy.IBk:__construct(c) -> getOptionList(oList) -> getWekaKNNConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.lazy.IBk:setOptions(c,oArray)
wekaKNN;	wekaCreateBaseClassifier(c); c,oList,oArray; ; ; weka.classifiers.lazy.IBk:__construct(c) -> getOptionList(oList) -> getWekaKNNConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.lazy.IBk:setOptions(c,oArray)
wekaKNN;	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; ; assignTo('weka.classifiers.lazy.IBk',cn) -> getWekaKNNConfig0(oList)
wekaKNN;	wekaSelectBaseClassifier(cn); cn; ; ; assignTo('weka.classifiers.lazy.IBk',cn)
wekaKNN;	wekaParametrizeGivenBaseClassifier(cn,oList); cn,oList; assigned('weka.classifiers.lazy.IBk',cn) ; ; getWekaKNNConfig0(oList)
# -E, -X. -I, -F optional, -I or -F, not both
wekaKNNOptsMeanSquared			; getWekaKNNConfig0(o);	o; ; ; addOptParam(o, '-E') -> getWekaKNNConfig1(o)
wekaKNNOptsCrossValidate		; getWekaKNNConfig1(o);	o; ; ; addOptParam(o, '-X') -> getWekaKNNConfig2(o)
wekaKNNOptsDistanceWeighingA	; getWekaKNNConfig2(o);	o; ; ; addOptParam(o, '-I') -> getWekaKNNConfig3(o)
wekaKNNOptsDistanceWeighingB1	; getWekaKNNConfig3(o);	o; in(o,'-I') ; ; noop -> getWekaKNNConfig4(o)
wekaKNNOptsDistanceWeighingA2	; getWekaKNNConfig3(o);	o; notin(o,'-I') ; ; addOptParam(o, '-F') -> getWekaKNNConfig4(o)
# -K <int> mandatory
wekaKNNOptsKNN					; getWekaKNNConfig4(o);	o,int; KNNKNN(int) ; ; addMandatValuedParam(o, '-K', int)

# KStar
#wekaKStar;	wekaCreateRawBaseClassifier(cn,c); cn,c; ; weka.classifiers.lazy.KStar:__construct(c) -> assignTo('weka.classifiers.lazy.KStar',cn)
#wekaKStar;	wekaCreateGivenBaseClassifier(cn,c); cn,c,oList,oArray; assigned('weka.classifiers.lazy.KStar',cn) ; weka.classifiers.lazy.KStar:__construct(c) -> getOptionList(oList) -> getWekaKStarConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.lazy.KStar:setOptions(c,oArray)
wekaKStar;	wekaCreateBaseClassifier(c); c,oList,oArray; ; ; weka.classifiers.lazy.KStar:__construct(c) -> getOptionList(oList) -> getWekaKStarConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.lazy.KStar:setOptions(c,oArray)
wekaKStar;	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; ;  assignTo('weka.classifiers.lazy.KStar',cn) -> getWekaKStarConfig0(oList)
wekaKStar;	wekaSelectBaseClassifier(cn); cn; ; ; assignTo('weka.classifiers.lazy.KStar',cn)
wekaKStar;	wekaParametrizeGivenBaseClassifier(cn,oList); cn,oList; assigned('weka.classifiers.lazy.KStar',cn) ;;  getWekaKStarConfig0(oList)
# -E optional
wekaKStarOptsEntropicAutoBlend	; getWekaKStarConfig0(o);	o; ; ; addOptParam(o, '-E') -> getWekaKStarConfig1(o)
# -B <float>, -M <type> mandatory
wekaKStarOptsGlobalBlend		; getWekaKStarConfig1(o);	o,float; KStarGlobalBlend(float) ; ; addMandatValuedParam(o, '-B', float) -> getWekaKStarConfig2(o)
wekaKStarOptsMissingMode		; getWekaKStarConfig2(o);	o,type; KStarMissingMode(type) ; ; addMandatValuedParam(o, '-M', type)

# Decision Tables
#wekaDecTable;	wekaCreateRawBaseClassifier(cn,c); cn,c; ; weka.classifiers.rules.DecisionTable:__construct(c) -> assignTo('weka.classifiers.rules.DecisionTable',cn)
#wekaDecTable;	wekaCreateGivenBaseClassifier(cn,c); cn,c,oList,oArray; assigned('weka.classifiers.rules.DecisionTable',cn) ; weka.classifiers.rules.DecisionTable:__construct(c) -> getOptionList(oList) -> getWekaDecTableConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.rules.DecisionTable:setOptions(c,oArray)
#wekaDecTable;	wekaCreateBaseClassifier(c); c,oList,oArray; ; ; weka.classifiers.rules.DecisionTable:__construct(c) -> getOptionList(oList) -> getWekaDecTableConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.rules.DecisionTable:setOptions(c,oArray)
#wekaDecTable;	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; ; assignTo('weka.classifiers.rules.DecisionTable',cn) -> getWekaDecTableConfig0(oList)
wekaDecTable;	wekaSelectBaseClassifier(cn); cn; ; ; assignTo('weka.classifiers.rules.DecisionTable',cn)
wekaDecTable;	wekaParametrizeGivenBaseClassifier(cn,oList); cn,oList; assigned('weka.classifiers.rules.DecisionTable',cn) ; ; getWekaDecTableConfig0(oList)
# -I optional
wekaDecTableOptsUseIBk		; getWekaDecTableConfig0(o);	o; ; ; addOptParam(o, '-I') -> getWekaDecTableConfig1(o)
# -E <type>, -S <class>, -X <type> mandatory
wekaDecTableOptsEvalMeasure	; getWekaDecTableConfig1(o);	o,type; DecTableEvalMeasure(type) ; ; addMandatValuedParam(o, '-E', type) -> getWekaDecTableConfig2(o)
wekaDecTableOptsSearch		; getWekaDecTableConfig2(o);	o,class; DecTableSearch(class) ; ; addMandatValuedParam(o, '-S', class) -> getWekaDecTableConfig3(o)
wekaDecTableOptsCrossVal	; getWekaDecTableConfig3(o);	o,type; DecTableCrossVal(type) ; ; addMandatValuedParam(o, '-X', type)

# RIPPER
#wekaRipper;	wekaCreateRawBaseClassifier(cn,c); cn,c; ; weka.classifiers.rules.JRip:__construct(c) -> assignTo('weka.classifiers.rules.JRip',cn)
#wekaRipper;	wekaCreateGivenBaseClassifier(cn,c); cn,c,oList,oArray; assigned('weka.classifiers.rules.JRip',cn) ; weka.classifiers.rules.JRip:__construct(c) -> getOptionList(oList) -> getWekaRipperConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.rules.JRip:setOptions(c,oArray)
wekaRipper;	wekaCreateBaseClassifier(c); c,oList,oArray; ; ; weka.classifiers.rules.JRip:__construct(c) -> getOptionList(oList) -> getWekaRipperConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.rules.JRip:setOptions(c,oArray)
wekaRipper;	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; ; assignTo('weka.classifiers.rules.JRip',cn) -> getWekaRipperConfig0(oList)
wekaRipper;	wekaSelectBaseClassifier(cn); cn; ; ; assignTo('weka.classifiers.rules.JRip',cn)
wekaRipper;	wekaParametrizeGivenBaseClassifier(cn,oList); cn,oList; assigned('weka.classifiers.rules.JRip',cn) ; ; getWekaRipperConfig0(oList)
# -E, -P optional
wekaRipperOptsCheckErrorRate	; getWekaRipperConfig0(o);	o; ; ; addOptParam(o, '-E') -> getWekaRipperConfig1(o)
wekaRipperOptsUsePruning		; getWekaRipperConfig1(o);	o; ; ; addOptParam(o, '-P') -> getWekaRipperConfig2(o)
# -N <float>, -O <int> mandatory
wekaRipperOptsMinNo				; getWekaRipperConfig2(o);	o,float; RipperMinNo(float) ; ; addMandatValuedParam(o, '-N', float) -> getWekaRipperConfig3(o)
wekaRipperOptsOptimizations		; getWekaRipperConfig3(o);	o,int; RipperOptimizations(int) ; ; addMandatValuedParam(o, '-O', int)

# M5Rules
#wekaM5Rules; wekaCreateRawBaseClassifier(cn,c); cn,c; ; weka.classifiers.rules.M5Rules:__construct(c) -> assignTo('weka.classifiers.rules.M5Rules',cn)
#wekaM5Rules; wekaCreateGivenBaseClassifier(cn,c); cn,c,oList,oArray; assigned('weka.classifiers.rules.M5Rules',cn) ; weka.classifiers.rules.M5Rules:__construct(c) -> getOptionList(oList) -> getWekaM5RulesConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.rules.M5Rules:setOptions(c,oArray)
wekaM5Rules; wekaCreateBaseClassifier(c); c,oList,oArray; ; ; weka.classifiers.rules.M5Rules:__construct(c) -> getOptionList(oList) -> getWekaM5RulesConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.rules.M5Rules:setOptions(c,oArray)
wekaM5Rules; wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; ; assignTo('weka.classifiers.rules.M5Rules',cn) -> getWekaM5RulesConfig0(oList)
wekaM5Rules; wekaSelectBaseClassifier(cn); cn; ; ; assignTo('weka.classifiers.rules.M5Rules',cn)
wekaM5Rules; wekaParametrizeGivenBaseClassifier(cn,oList); cn,oList; assigned('weka.classifiers.rules.M5Rules',cn) ; ; getWekaM5RulesConfig0(oList)
# -N, -U, -R optional
wekaM5RulesOptsUnpruned			; getWekaM5RulesConfig0(o);	o; ; ; addOptParam(o, '-N') -> getWekaM5RulesConfig1(o)
wekaM5RulesOptsUseUnsmoothed	; getWekaM5RulesConfig1(o);	o; ; ; addOptParam(o, '-U') -> getWekaM5RulesConfig2(o)
wekaM5RulesOptBuildRegressionTree	; getWekaM5RulesConfig2(o);	o; ; ; addOptParam(o, '-R') -> getWekaM5RulesConfig3(o)
# -M <int> mandatory
wekaM5RulesOptsMinNumInstances	; getWekaM5RulesConfig3(o);	o,int; M5RulesMinNumInstances(int) ; ; addMandatValuedParam(o, '-M', int)

# OneR
#wekaOneR; wekaCreateRawBaseClassifier(cn,c); cn,c; ; weka.classifiers.rules.OneR:__construct(c) -> assignTo('weka.classifiers.rules.OneR',cn)
#wekaOneR; wekaCreateGivenBaseClassifier(cn,c); cn,c,oList,oArray; assigned('weka.classifiers.rules.OneR',cn) ; weka.classifiers.rules.OneR:__construct(c) -> getOptionList(oList) -> getWekaOneRConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.rules.OneR:setOptions(c,oArray)
#wekaOneR; wekaCreateBaseClassifier(c); c,oList,oArray; ; ; weka.classifiers.rules.OneR:__construct(c) -> getOptionList(oList) -> getWekaOneRConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.rules.OneR:setOptions(c,oArray)
#wekaOneR; wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; ; assignTo('weka.classifiers.rules.OneR',cn) -> getWekaOneRConfig0(oList)
wekaOneR; wekaSelectBaseClassifier(cn); cn; ; ; assignTo('weka.classifiers.rules.OneR',cn)
wekaOneR; wekaParametrizeGivenBaseClassifier(cn,oList); cn,oList; assigned('weka.classifiers.rules.OneR',cn) ; ; getWekaOneRConfig0(oList)
# -B <int> mandatory
wekaOneROptsMinBucketSize	; getWekaOneRConfig0(o);	o,int; OneRMinBucketSize(int) ; ; addMandatValuedParam(o, '-B', int)

# PART
#wekaPART; wekaCreateRawBaseClassifier(cn,c); cn,c; ; weka.classifiers.rules.PART:__construct(c) -> assignTo('weka.classifiers.rules.PART',cn)
#wekaPART; wekaCreateGivenBaseClassifier(cn,c); cn,c,oList,oArray; assigned('weka.classifiers.rules.PART',cn) ; weka.classifiers.rules.PART:__construct(c) -> getOptionList(oList) -> getWekaPARTConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.rules.PART:setOptions(c,oArray)
wekaPART; wekaCreateBaseClassifier(c); c,oList,oArray; ; ; weka.classifiers.rules.PART:__construct(c) -> getOptionList(oList) -> getWekaPARTConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.rules.PART:setOptions(c,oArray)
wekaPART; wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; ; assignTo('weka.classifiers.rules.PART',cn) -> getWekaPARTConfig0(oList)
wekaPART; wekaSelectBaseClassifier(cn); cn; ; ; assignTo('weka.classifiers.rules.PART',cn)
wekaPART; wekaParametrizeGivenBaseClassifier(cn,oList); cn,oList; assigned('weka.classifiers.rules.PART',cn) ; ; getWekaPARTConfig0(oList)
# -B, -R optional
wekaPARTOptsBinarySplits			; getWekaPARTConfig0(o);	o; ; ; addOptParam(o, '-B') -> getWekaPARTConfig1(o)
wekaPARTOptsReducedErrorPruning		; getWekaPARTConfig1(o);	o; ; ; addOptParam(o, '-R') -> getWekaPARTConfig2(o)
# -M <int>, -N <int> mandatory; IF R THEN N
wekaPARTOptsMinNumObj	; getWekaPARTConfig2(o);	o,int; PARTMinNumObj(int) ; ; addMandatValuedParam(o, '-M', int) -> getWekaPARTConfig3(o)
wekaPARTOptsNumFoldsN	; getWekaPARTConfig3(o);	o; notin(o,'-R') ; ; noop
wekaPARTOptsNumFoldsY	; getWekaPARTConfig3(o);	o,int; in(o,'-R') & PARTNumFolds(int) ; ; addMandatValuedParam(o, '-N', int)

# ZeroR
#wekaZeroR; wekaCreateRawBaseClassifier(cn,c); cn,c; ; weka.classifiers.rules.ZeroR:__construct(c) -> assignTo('weka.classifiers.rules.ZeroR',cn)
#wekaZeroR; wekaCreateGivenBaseClassifier(cn,c); cn,c,oList,oArray; assigned('weka.classifiers.rules.ZeroR',cn) ; weka.classifiers.rules.ZeroR:__construct(c) -> getOptionList(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.rules.ZeroR:setOptions(c,oArray)
#wekaZeroR; wekaCreateBaseClassifier(c); c,oList,oArray; ; ; weka.classifiers.rules.ZeroR:__construct(c) -> getOptionList(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.rules.ZeroR:setOptions(c,oArray)
#wekaZeroR; wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; ; assignTo('weka.classifiers.rules.ZeroR',cn)
wekaZeroR; wekaSelectBaseClassifier(cn); cn; ; ; assignTo('weka.classifiers.rules.ZeroR',cn)
wekaZeroR; wekaParametrizeGivenBaseClassifier(cn,oList); cn,oList; assigned('weka.classifiers.rules.ZeroR',cn) ; ; noop
# No parameters.

# Decision Stump
#wekaDecisionStump; wekaCreateRawBaseClassifier(cn,c); cn,c; ; weka.classifiers.trees.DecisionStump:__construct(c) -> assignTo('weka.classifiers.trees.DecisionStump',cn)
#wekaDecisionStump; wekaCreateGivenBaseClassifier(cn,c); cn,c,oList,oArray; assigned('weka.classifiers.trees.DecisionStump',cn) ; weka.classifiers.trees.DecisionStump:__construct(c) -> getOptionList(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.trees.DecisionStump:setOptions(c,oArray)
#wekaDecisionStump; wekaCreateBaseClassifier(c); c,oList,oArray; ; ; weka.classifiers.trees.DecisionStump:__construct(c) -> getOptionList(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.trees.DecisionStump:setOptions(c,oArray)
#wekaDecisionStump; wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; ; assignTo('weka.classifiers.trees.DecisionStump',cn)
wekaDecisionStump; wekaSelectBaseClassifier(cn); cn; ; ; assignTo('weka.classifiers.trees.DecisionStump',cn)
wekaDecisionStump; wekaParametrizeGivenBaseClassifier(cn,oList); cn,oList; assigned('weka.classifiers.trees.DecisionStump',cn) ; ; noop
# No parameters.

# Decision Trees C4.5
#wekaDT; 	wekaCreateRawBaseClassifier(cn,c); cn,c; ; weka.classifiers.trees.J48:__construct(c) -> assignTo('weka.classifiers.trees.J48',cn)
#wekaDT; 	wekaCreateGivenBaseClassifier(cn,c); cn,c,oList,oArray; assigned('weka.classifiers.trees.J48',cn) ; weka.classifiers.trees.J48:__construct(c) -> getOptionList(oList) -> getWekaDTConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.trees.J48:setOptions(c,oArray)
wekaDT; 	wekaCreateBaseClassifier(c); c,oList,oArray; ; ; weka.classifiers.trees.J48:__construct(c) -> getOptionList(oList) -> getWekaDTConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.trees.J48:setOptions(c,oArray)
wekaDT; 	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; ; assignTo('weka.classifiers.trees.J48',cn) -> getWekaDTConfig0(oList)
wekaDT; 	wekaSelectBaseClassifier(cn); cn; ; ; assignTo('weka.classifiers.trees.J48',cn)
wekaDT; 	wekaParametrizeGivenBaseClassifier(cn,oList); cn,oList; assigned('weka.classifiers.trees.J48',cn) ; ; getWekaDTConfig0(oList)
# -A, -B, -J, -O optional
wekaDTOptsUseLaplace		; getWekaDTConfig0(o);	o; ; ; addOptParam(o, '-A') -> getWekaDTConfig1(o)
wekaDTOptsBinarySplits		; getWekaDTConfig1(o);	o; ; ; addOptParam(o, '-B') -> getWekaDTConfig2(o)
wekaDTOptsUseMDLCorrection	; getWekaDTConfig2(o);	o; ; ; addOptParam(o, '-J') -> getWekaDTConfig3(o)
wekaDTOptsCollapseTree		; getWekaDTConfig3(o);	o; ; ; addOptParam(o, '-O') -> getWekaDTConfig4(o)
wekaDTOptsSubtreeRaising	; getWekaDTConfig4(o);	o; ; ; addOptParam(o, '-S') -> getWekaDTConfig5(o)
# -S, -U optional, not both -S and -U set
wekaDTOptsErrorUnpruned		; getWekaDTConfig5(o);	o; in(o,'-S') ; ; noop -> getWekaDTConfig6(o)
wekaDTOptsErrorUnpruned		; getWekaDTConfig5(o);	o; notin(o,'-S') ; ; addOptParam(o, '-U') -> getWekaDTConfig6(o)
# -C <int> mandatory, only if -U not present
wekaDTOptsConfidenceFactor	; getWekaDTConfig6(o);	o; in(o,'-U') ; ; noop -> getWekaDTConfig7(o)
wekaDTOptsConfidenceFactor	; getWekaDTConfig6(o);	o,float; notin(o,'-U') & DTConfidenceFactor(float) ; ; addMandatValuedParam(o, '-C', float) -> getWekaDTConfig7(o)
# -M <int> mandatory
wekaDTOptsMinNumObj	; getWekaDTConfig7(o);	o,int; DTMinNumObj(int) ; ; addMandatValuedParam(o, '-M', int)

# Logistic Model Tree
#wekaLMT; 	wekaCreateRawBaseClassifier(cn,c); cn,c; ; weka.classifiers.trees.LMT:__construct(c) -> assignTo('weka.classifiers.trees.LMT',cn)
#wekaLMT; 	wekaCreateGivenBaseClassifier(cn,c); cn,c,oList,oArray; assigned('weka.classifiers.trees.LMT',cn) ; weka.classifiers.trees.LMT:__construct(c) -> getOptionList(oList) -> getWekaLMTConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.trees.LMT:setOptions(c,oArray)
wekaLMT; 	wekaCreateBaseClassifier(c); c,oList,oArray; ; ; weka.classifiers.trees.LMT:__construct(c) -> getOptionList(oList) -> getWekaLMTConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.trees.LMT:setOptions(c,oArray)
wekaLMT; 	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; ; assignTo('weka.classifiers.trees.LMT',cn) -> getWekaLMTConfig0(oList)
wekaLMT; 	wekaSelectBaseClassifier(cn); cn; ; ; assignTo('weka.classifiers.trees.LMT',cn)
wekaLMT; 	wekaParametrizeGivenBaseClassifier(cn,oList); cn,oList; assigned('weka.classifiers.trees.LMT',cn) ; ; getWekaLMTConfig0(oList)
# -A, -B, -C, -R, -P optional
wekaLMTOptsUseAIC			; getWekaLMTConfig0(o);	o; ; ; addOptParam(o, '-A') -> getWekaLMTConfig1(o)
wekaLMTOptsConvertNominals	; getWekaLMTConfig1(o);	o; ; ; addOptParam(o, '-B') -> getWekaLMTConfig2(o)
wekaLMTOptsFastRegression	; getWekaLMTConfig2(o);	o; ; ; addOptParam(o, '-C') -> getWekaLMTConfig3(o)
wekaLMTOptsErrorOnProb		; getWekaLMTConfig3(o);	o; ; ; addOptParam(o, '-P') -> getWekaLMTConfig4(o)
wekaLMTOptsSplitOnResiduals	; getWekaLMTConfig4(o);	o; ; ; addOptParam(o, '-R') -> getWekaLMTConfig5(o)
# -M <int> mandatory
wekaLMTOptsMinNumInstances	; getWekaLMTConfig5(o);	o,int; LMTMinNumInstances(int) ; ; addMandatValuedParam(o, '-M', int) -> getWekaLMTConfig6(o)
# -W <float> mandatory, value 0 for unused
wekaLMTOptsWeightTrimBeta	; getWekaLMTConfig6(o);	o; ; ; addMandatValuedParam(o, '-W', '0')
wekaLMTOptsWeightTrimBeta	; getWekaLMTConfig6(o);	o,float; LMTWeightTrimBeta(float) ; ; addMandatValuedParam(o, '-W', float)


####### Problem in LMT: single remaining OPEN node sometimes


# M5 Tree
#wekaM5P; 	wekaCreateRawBaseClassifier(cn,c); cn,c; ; weka.classifiers.trees.M5P:__construct(c) -> assignTo('weka.classifiers.trees.M5P',cn)
#wekaM5P; 	wekaCreateGivenBaseClassifier(cn,c); cn,c,oList,oArray; assigned('weka.classifiers.trees.M5P',cn) ; weka.classifiers.trees.M5P:__construct(c) -> getOptionList(oList) -> getWekaM5PConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.trees.M5P:setOptions(c,oArray)
#wekaM5P; 	wekaCreateBaseClassifier(c); c,oList,oArray; ; ; weka.classifiers.trees.M5P:__construct(c) -> getOptionList(oList) -> getWekaM5PConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.trees.M5P:setOptions(c,oArray)
#wekaM5P; 	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; ; assignTo('weka.classifiers.trees.M5P',cn) -> getWekaM5PConfig0(oList)
wekaM5P; 	wekaSelectBaseClassifier(cn); cn; ; ; assignTo('weka.classifiers.trees.M5P',cn)
wekaM5P; 	wekaParametrizeGivenBaseClassifier(cn,oList); cn,oList; assigned('weka.classifiers.trees.M5P',cn) ; ;  getWekaM5PConfig0(oList)
# -N, -U, -R optional
wekaM5POptsUnpruned			; getWekaM5PConfig0(o);	o; ; ; addOptParam(o, '-N') -> getWekaM5PConfig1(o)
wekaM5POptsUseUnsmoothed	; getWekaM5PConfig1(o);	o; ; ; addOptParam(o, '-U') -> getWekaM5PConfig2(o)
wekaM5POptsBuildRegTree		; getWekaM5PConfig2(o);	o; ; ; addOptParam(o, '-R') -> getWekaM5PConfig3(o)
# -M <int> mandatory
wekaM5POptsMinNumInstances	; getWekaM5PConfig3(o);	o,int; M5PMinNumInstances(int) ; ; addMandatValuedParam(o, '-M', int)

# Random Forest
#wekaRF; 	wekaCreateRawBaseClassifier(cn,c); cn,c; ; weka.classifiers.trees.RandomForest:__construct(c) -> assignTo('weka.classifiers.trees.RandomForest',cn)
#wekaRF; 	wekaCreateGivenBaseClassifier(cn,c); cn,c,oList,oArray; assigned('weka.classifiers.trees.RandomForest',cn) ; weka.classifiers.trees.RandomForest:__construct(c) -> getOptionList(oList) -> getWekaRFConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.trees.RandomForest:setOptions(c,oArray)
wekaRF; 	wekaCreateBaseClassifier(c); c,oList,oArray; ; ; weka.classifiers.trees.RandomForest:__construct(c) -> getOptionList(oList) -> getWekaRFConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.trees.RandomForest:setOptions(c,oArray)
wekaRF; 	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; ; assignTo('weka.classifiers.trees.RandomForest',cn) -> getWekaRFConfig0(oList)
wekaRF; 	wekaSelectBaseClassifier(cn); cn; ; ; assignTo('weka.classifiers.trees.RandomForest',cn)
wekaRF; 	wekaParametrizeGivenBaseClassifier(cn,oList); cn,oList; assigned('weka.classifiers.trees.RandomForest',cn) ; ; getWekaRFConfig0(oList)
# -I <int> mandatory
wekaRFOptsNumIterations	; getWekaRFConfig0(o);	o,int; RFNumIterations(int) ; ; addMandatValuedParam(o, '-I', int) -> getWekaRFConfig1(o)
# -K <int> mandatory, value 0 for unused
wekaRFOptsNumFeatures	; getWekaRFConfig1(o);	o; ; ; addMandatValuedParam(o, '-K', '0') -> getWekaRFConfig2(o)
wekaRFOptsNumFeatures	; getWekaRFConfig1(o);	o,int; RFNumFeatures(int) ; ; addMandatValuedParam(o, '-K', int) -> getWekaRFConfig2(o)
# -depth <int> mandatory, value 0 for unused
wekaRFOptsMaxDepth		; getWekaRFConfig2(o);	o; ; ; addMandatValuedParam(o, '-depth', '0')
wekaRFOptsMaxDepth		; getWekaRFConfig2(o);	o,int; RFMaxDepth(int) ; ; addMandatValuedParam(o, '-depth', int)

# Random Tree
#wekaRT; 	wekaCreateRawBaseClassifier(cn,c); cn,c; ; weka.classifiers.trees.RandomTree:__construct(c) -> assignTo('weka.classifiers.trees.RandomTree',cn)
#wekaRT; 	wekaCreateGivenBaseClassifier(cn,c); cn,c,oList,oArray; assigned('weka.classifiers.trees.RandomTree',cn) ; weka.classifiers.trees.RandomTree:__construct(c) -> getOptionList(oList) -> getWekaRTConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.trees.RandomTree:setOptions(c,oArray)
wekaRT; 	wekaCreateBaseClassifier(c); c,oList,oArray; ; ; weka.classifiers.trees.RandomTree:__construct(c) -> getOptionList(oList) -> getWekaRTConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.trees.RandomTree:setOptions(c,oArray)
wekaRT; 	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; ; assignTo('weka.classifiers.trees.RandomTree',cn) -> getWekaRTConfig0(oList)
wekaRT; 	wekaSelectBaseClassifier(cn); cn; ; ; assignTo('weka.classifiers.trees.RandomTree',cn)
wekaRT; 	wekaParametrizeGivenBaseClassifier(cn,oList); cn,oList; assigned('weka.classifiers.trees.RandomTree',cn) ; ; getWekaRTConfig0(oList)
# -U optional
wekaRTOptsAllowUnclass	; getWekaRTConfig0(o);	o; ; ; addOptParam(o, '-U') -> getWekaRTConfig1(o)
# -K <int> mandatory, value 0 for unused
wekaRTOptsKValue		; getWekaRTConfig1(o);	o; ; ; addMandatValuedParam(o, '-K', '0') -> getWekaRTConfig2(o)
wekaRTOptsKValue		; getWekaRTConfig1(o);	o,int; RTKValue(int) ; ; addMandatValuedParam(o, '-K', int) -> getWekaRTConfig2(o)
# -M <int> mandatory
wekaRTOptsMinNum		; getWekaRTConfig2(o);	o,int; RTMinNum(int) ; ; addMandatValuedParam(o, '-M', int) -> getWekaRTConfig3(o)
# -N <int> mandatory, value 0 for unused
wekaRTOptsNumFolds	; getWekaRTConfig3(o);	o; ; ; addMandatValuedParam(o, '-N', '0') -> getWekaRTConfig4(o)
wekaRTOptsNumFolds	; getWekaRTConfig3(o);	o,int; RTNumFolds(int) ; ; addMandatValuedParam(o, '-N', int) -> getWekaRTConfig4(o)
# -depth <int> mandatory, value 0 for unused
wekaRTOptsMaxDepth	; getWekaRTConfig4(o);	o; ; ; addMandatValuedParam(o, '-depth', '0')
wekaRTOptsMaxDepth	; getWekaRTConfig4(o);	o,int; RTMaxDepth(int) ; ; addMandatValuedParam(o, '-depth', int)

# REP Tree
#wekaREP; 	wekaCreateRawBaseClassifier(cn,c); cn,c; ; weka.classifiers.trees.REPTree:__construct(c) -> assignTo('weka.classifiers.trees.REPTree',cn)
#wekaREP; 	wekaCreateGivenBaseClassifier(cn,c); cn,c,oList,oArray; assigned('weka.classifiers.trees.REPTree',cn) ; weka.classifiers.trees.REPTree:__construct(c) -> getOptionList(oList) -> getWekaREPConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.trees.REPTree:setOptions(c,oArray)
#wekaREP; 	wekaCreateBaseClassifier(c); c,oList,oArray; ; ; weka.classifiers.trees.REPTree:__construct(c) -> getOptionList(oList) -> getWekaREPConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.trees.REPTree:setOptions(c,oArray)
#wekaREP; 	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; ; assignTo('weka.classifiers.trees.REPTree',cn) -> getWekaREPConfig0(oList)
wekaREP; 	wekaSelectBaseClassifier(cn); cn; ; ; assignTo('weka.classifiers.trees.REPTree',cn)
wekaREP; 	wekaParametrizeGivenBaseClassifier(cn,oList); cn,oList; assigned('weka.classifiers.trees.REPTree',cn) ; ; getWekaREPConfig0(oList)
# -P optional
wekaREPOptsPruning			; getWekaREPConfig0(o);	o; ; ; addOptParam(o, '-P') -> getWekaREPConfig1(o)
# -L <int> mandatory, value -1 for unused
wekaREPOptsMaxDepth		; getWekaREPConfig1(o);	o; ; ; addMandatValuedParam(o, '-L', '-1') -> getWekaREPConfig2(o)
wekaREPOptsMaxDepth		; getWekaREPConfig1(o);	o,int; REPMaxDepth(int) ; ; addMandatValuedParam(o, '-L', int) -> getWekaREPConfig2(o)
# -M <int>, -V <float> mandatory
wekaREPOptsMinNum		; getWekaREPConfig2(o);	o,int; REPMinNum(int) ; ; addMandatValuedParam(o, '-M', int) -> getWekaREPConfig3(o)
wekaREPOptsMinVariance	; getWekaREPConfig3(o);	o,float; REPMinVariance(float) ; ; addMandatValuedParam(o, '-V', float)


# Nested Dichotomies
#wekaNDs;	wekaCreateBaseClassifier(c); c; ; wekaCreateNDClassifier(c)
rpnd;	wekaCreateNDClassifier(c);	c,oList,oArray; ;	; weka.classifiers.meta.nestedDichotomies.RandomPairND:__construct(c) -> getOptionList(oList) -> getWekaNDConfig(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.nestedDichotomies.RandomPairND:setOptions(c,oArray)
cbnd;	wekaCreateNDClassifier(c);	c,oList,oArray; ;	; weka.classifiers.meta.nestedDichotomies.ClassBalancedND:__construct(c) -> getOptionList(oList) -> getWekaNDConfig(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.nestedDichotomies.ClassBalancedND:setOptions(c,oArray)
dnbnd;	wekaCreateNDClassifier(c);	c,oList,oArray; ;	; weka.classifiers.meta.nestedDichotomies.DataNearBalancedND:__construct(c) -> getOptionList(oList) -> getWekaNDConfig(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.nestedDichotomies.DataNearBalancedND:setOptions(c,oArray)
fcnd;	wekaCreateNDClassifier(c);	c,oList,oArray; ;	; weka.classifiers.meta.nestedDichotomies.FurthestCentroidND:__construct(c) -> getOptionList(oList) -> getWekaNDConfig(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.nestedDichotomies.FurthestCentroidND:setOptions(c,oArray)
nd;		wekaCreateNDClassifier(c);	c,oList,oArray; ;	; weka.classifiers.meta.nestedDichotomies.ND:__construct(c) -> getOptionList(oList) -> getWekaNDConfig(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.nestedDichotomies.ND:setOptions(c,oArray)
wekaNDOptsClose				; getWekaNDConfig(o);	o; ; ; noop
wekaNDOptsSetBaseLearner	; getWekaNDConfig(o);	o; ; ; addWekaBaseLearner(o) -> getWekaNDConfig(o)


### META CLASSIFIERS ###

# Parametrization of selected base classifier:
wekaMetaBaseClassifier			; getWekaGivenBaseConfig(cnLocal,o);	o,cnLocal,oLocal; ; ; getOptionList(oLocal) -> wekaParametrizeGivenBaseClassifier(cnLocal, oLocal) -> addMandatValuedParam(o, '-W', cnLocal) -> addMandatParam(o, '--') -> appendOptions(o, oLocal)
#wekaMetaBaseClassifier			; getWekaGivenBaseConfig(cnLocal,o);	o,cnLocal,oLocal; ; getOptionList(oLocal) -> addMandatValuedParam(o, '-W', cnLocal) -> addMandatParam(o, '--') -> appendOptions(o, oLocal)

# Locally Weighted Learning
wekaLWL;	wekaCreateMetaClassifier(c); c,oList,cnLocal,oArray; ; ; weka.classifiers.lazy.LWL:__construct(c) -> wekaSelectBaseClassifier(cnLocal) -> getOptionList(oList) -> getWekaLWLConfig0(oList) -> getWekaGivenBaseConfig(cnLocal,oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.lazy.LWL:setOptions(c,oArray)
# -A <class> mandatory
wekaLWLOptsNearestNeighbourSearch	; getWekaLWLConfig0(o);	o,name,oLocal,param; LWLNearestNeighbourSearch(name) ; ; getOptionList(oLocal) -> addMandatParam(oLocal,name) -> concatenate(oLocal,param) -> addMandatValuedParam(o, '-A', param) -> getWekaLWLConfig1(o)
# -K <int> optional
wekaLWLOptsKNN						; getWekaLWLConfig1(o);	o,int; LWLKNN(int) ; ; addOptValuedParam(o, '-K', int) -> getWekaLWLConfig2(o)
# -U <int> optional, -K or -U has to be used
wekaLWLOptsWeighingKernel			; getWekaLWLConfig2(o);	o,int; notin(o,'-K') & LWLWeighingKernel(int) ; ; addMandatValuedParam(o, '-U', int)
wekaLWLOptsWeighingKernel			; getWekaLWLConfig2(o);	o,int; in(o,'-K') & LWLWeighingKernel(int) ; ; addOptValuedParam(o, '-U', int)
# -W <base> mandatory: see global method at beginning of META CLASSIFIERS section

# AdaBoost
#wekaAdaBoost;	wekaCreateMetaClassifier(c); c,oList,cnLocal,oArray; ; ; weka.classifiers.meta.AdaBoostM1:__construct(c) -> wekaSelectBaseClassifier(cnLocal) -> getOptionList(oList) -> getWekaAdaBoostConfig0(oList) -> getWekaGivenBaseConfig(cnLocal,oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.AdaBoostM1:setOptions(c,oArray)
# -Q optional
wekaAdaBoostOptsUseResampling	; getWekaAdaBoostConfig0(o);	o; ; ; addOptParam(o, '-Q') -> getWekaAdaBoostConfig1(o)
# -I <int> mandatory
wekaAdaBoostOptsNumIterations	; getWekaAdaBoostConfig1(o);	o,int; AdaBoostNumIterations(int) ; ; addMandatValuedParam(o, '-I', int) -> getWekaAdaBoostConfig2(o)
# -P <int> mandatory, value 100 for unused
wekaAdaBoostOptsWeightThreshold	; getWekaAdaBoostConfig2(o);	o; ; ; addMandatValuedParam(o, '-P', '100') -> getWekaAdaBoostConfig3(o)
wekaAdaBoostOptsWeightThreshold	; getWekaAdaBoostConfig2(o);	o,int; AdaBoostWeightThreshold(int) ; ; addMandatValuedParam(o, '-P', int) -> getWekaAdaBoostConfig3(o)
# -S 1  mandatory
wekaAdaBoostOptsSeed			; getWekaAdaBoostConfig3(o);	o; ; ; addMandatValuedParam(o, '-S', '1')
# -W <base> mandatory: see global method at beginning of META CLASSIFIERS section

# MultiBoost
#wekaMultiBoost; wekaCreateMetaClassifier(c); c,oList,cnLocal,oArray; ; weka.classifiers.meta.MultiBoostAB:__construct(c) -> wekaSelectBaseClassifier(cnLocal) -> getOptionList(oList) -> getWekaGivenBaseConfig(cnLocal,oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.MultiBoostAB:setOptions(c,oArray)
# -W <base> mandatory: see global method at beginning of META CLASSIFIERS section

# Additive Regression
#wekaAddReg; wekaCreateMetaClassifier(c); c,oList,cnLocal,oArray; ; ; weka.classifiers.meta.AdditiveRegression:__construct(c) -> wekaSelectBaseClassifier(cnLocal) -> getOptionList(oList) -> getWekaAddRegConfig0(oList) -> getWekaGivenBaseConfig(cnLocal,oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.AdditiveRegression:setOptions(c,oArray)
# -I <int>  mandatory
wekaAddRegOptsNumIterations	; getWekaAddRegConfig0(o);	o,int; AddRegNumIterations(int) ; ; addMandatValuedParam(o, '-I', int) -> getWekaAddRegConfig1(o)
# -S <float> mandatory, value 1 for unused
wekaAddRegOptsShrinkage	; getWekaAddRegConfig1(o);	o;  ; ; addMandatValuedParam(o, '-S', '1')
wekaAddRegOptsShrinkage	; getWekaAddRegConfig1(o);	o,float; AddRegShrinkage(float) ; ; addMandatValuedParam(o, '-S', float)
# -W <base> mandatory: see global method at beginning of META CLASSIFIERS section

# Attribute Selected
wekaAttributeSelected; wekaCreateMetaClassifier(c); c,oList,cnLocal,oArray; ; ; weka.classifiers.meta.AttributeSelectedClassifier:__construct(c) -> wekaSelectBaseClassifier(cnLocal) -> getOptionList(oList) -> getWekaAttributeSelectedConfig0(oList) -> getWekaGivenBaseConfig(cnLocal,oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.AttributeSelectedClassifier:setOptions(c,oArray)
# -S <class>, -E <class>  mandatory
wekaAddRegOptsSearchAndEval	; getWekaAttributeSelectedConfig0(o);	o,oLocal; ; ; getOptionList(oLocal) -> getWekaASConfig0(oLocal) -> appendOptions(o, oLocal)
# -W <base> mandatory: see global method at beginning of META CLASSIFIERS section

# Bagging
#wekaBagging;	wekaCreateMetaClassifier(c); c,oList,cnLocal,oArray; ; ; weka.classifiers.meta.Bagging:__construct(c) -> wekaSelectBaseClassifier(cnLocal) -> getOptionList(oList) -> getWekaBaggingConfig0(oList) -> getWekaGivenBaseConfig(cnLocal,oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.Bagging:setOptions(c,oArray)
# -O optional
wekaBaggingOptsCalcOutOfBag		; getWekaBaggingConfig0(o);	o; ; ; addOptParam(o, '-O') -> getWekaBaggingConfig1(o)
# -I <int> mandatory
wekaBaggingOptsNumIterations	; getWekaBaggingConfig1(o);	o,int; BaggingNumIterations(int) ; ; addMandatValuedParam(o, '-I', int) -> getWekaBaggingConfig2(o)
# -P <int> mandatory
wekaBaggingOptsBagSizePercent	; getWekaBaggingConfig2(o);	o; in(o,'-O') ; ; addMandatValuedParam(o, '-P', '100') -> getWekaBaggingConfig3(o)
wekaBaggingOptsBagSizePercent	; getWekaBaggingConfig2(o);	o,int; notin(o,'-O') & BaggingBagSizePercent(int) ; ; addMandatValuedParam(o, '-P', int) -> getWekaBaggingConfig3(o)
# -S 1  mandatory
wekaBaggingOptsSeed				; getWekaBaggingConfig3(o);	o; ; ; addMandatValuedParam(o, '-S', '1')
# -W <base> mandatory: see global method at beginning of META CLASSIFIERS section

# Classification via Regression
#wekaClassificationViaRegression; wekaCreateMetaClassifier(c); c,oList,cnLocal,oArray; ; ; weka.classifiers.meta.ClassificationViaRegression:__construct(c) -> wekaSelectBaseClassifier(cnLocal) -> getOptionList(oList) -> getWekaGivenBaseConfig(cnLocal,oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.ClassificationViaRegression:setOptions(c,oArray)
# -W <base> mandatory: see global method at beginning of META CLASSIFIERS section

# Logit Boost
#wekaLogitBoost; wekaCreateMetaClassifier(c); c,oList,cnLocal,oArray; ; ; weka.classifiers.meta.LogitBoost:__construct(c) -> wekaSelectBaseClassifier(cnLocal) -> getOptionList(oList) -> getWekaLogitBoostConfig0(oList) -> getWekaGivenBaseConfig(cnLocal,oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.LogitBoost:setOptions(c,oArray)
# -Q optional
wekaLogitBoostOptsUseResampling			; getWekaLogitBoostConfig0(o);	o; ; ; addOptParam(o, '-Q') -> getWekaLogitBoostConfig1(o)
# -I <int> mandatory
wekaLogitBoostOptsNumIterations			; getWekaLogitBoostConfig1(o);	o,int; LogitBoostNumIterations(int) ; ; addMandatValuedParam(o, '-I', int) -> getWekaLogitBoostConfig2(o)
# -H <float> mandatory, value 1 for unused
wekaLogitBoostOptsShrinkage				; getWekaLogitBoostConfig2(o);	o;  ; ; addMandatValuedParam(o, '-H', '1') -> getWekaLogitBoostConfig5(o)
wekaLogitBoostOptsShrinkage				; getWekaLogitBoostConfig2(o);	o,float; LogitBoostShrinkage(float) ; ; addMandatValuedParam(o, '-H', float) -> getWekaLogitBoostConfig5(o)
# -R <int> mandatory: NOT AVAILABLE IN WEKA 3.8, THEREFORE SKIPPED!!
wekaLogitBoostOptsNumRuns				; getWekaLogitBoostConfig3(o);	o,int; LogitBoostNumRuns(int) ; ; addMandatValuedParam(o, '-R', int) -> getWekaLogitBoostConfig4(o)
# -F <int> mandatory, value 0 for unused: NOT AVAILABLE IN WEKA 3.8, THEREFORE SKIPPED!!
wekaLogitBoostOptsNumFolds				; getWekaLogitBoostConfig4(o);	o;  ; ; addMandatValuedParam(o, '-F', '0') -> getWekaLogitBoostConfig5(o)
wekaLogitBoostOptsNumFolds				; getWekaLogitBoostConfig4(o);	o,int; LogitBoostNumFolds(int) ; ; addMandatValuedParam(o, '-F', int) -> getWekaLogitBoostConfig5(o)
# -P <int> mandatory, value 100 for unused
wekaLogitBoostOptsWeightThreshold		; getWekaLogitBoostConfig5(o);	o; in(o,'-Q') ; ; noop -> getWekaLogitBoostConfig6(o)
wekaLogitBoostOptsWeightThreshold		; getWekaLogitBoostConfig5(o);	o,int; notin(o,'-Q') & LogitBoostWeightThreshold(int) ; ; addMandatValuedParam(o, '-P', int) -> getWekaLogitBoostConfig6(o)
# -L 1e50  mandatory
wekaLogitBoostOptsLikelihoodThreshold 	; getWekaLogitBoostConfig6(o);	o; ; ; addMandatValuedParam(o, '-L', '1e50') -> getWekaLogitBoostConfig7(o)
# -S 1  mandatory
wekaLogitBoostOptsSeed					; getWekaLogitBoostConfig7(o);	o; ; ; addMandatValuedParam(o, '-S', '1')
# -W <base> mandatory: see global method at beginning of META CLASSIFIERS section

# MultiClass Classifier
wekaMCC; wekaCreateMetaClassifier(c); c,oList,cnLocal,oArray; ; ; weka.classifiers.meta.MultiClassClassifier:__construct(c) -> wekaSelectBaseClassifier(cnLocal) -> getOptionList(oList) -> getWekaMCCConfig0(oList) -> getWekaGivenBaseConfig(cnLocal,oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.MultiClassClassifier:setOptions(c,oArray)
# -P optional
wekaMCCOptsUsePairwiseCoupling	; getWekaMCCConfig0(o);	o; ; ; addOptParam(o, '-P') -> getWekaMCCConfig1(o)
# -M <type> mandatory
wekaMCCOptsMethod				; getWekaMCCConfig1(o);	o,type; MCCMethod(type) ; ; addMandatValuedParam(o, '-M', type) -> getWekaMCCConfig2(o)
# -R <float> mandatory
wekaMCCOptsRandomWidthFactor	; getWekaMCCConfig2(o);	o,float; MCCRandomWidthFactor(float) ; ; addMandatValuedParam(o, '-R', float) -> getWekaMCCConfig3(o)
# -S 1  mandatory
wekaMCCOptsSeed					; getWekaMCCConfig3(o);	o; ; ; addMandatValuedParam(o, '-S', '1')
# -W <base> mandatory: see global method at beginning of META CLASSIFIERS section

# Random Comittee
wekaRandomCommittee; wekaCreateMetaClassifier(c); c,oList,cnLocal,oArray; ; ; weka.classifiers.meta.RandomCommittee:__construct(c) -> wekaSelectBaseClassifier(cnLocal) -> getOptionList(oList) -> getWekaRandomComitteeConfig0(oList) -> getWekaGivenBaseConfig(cnLocal,oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.RandomCommittee:setOptions(c,oArray)
# -I <int>, -S 1  mandatory
wekaRandomComitteeOptsNumIterations		; getWekaRandomComitteeConfig0(o);	o,int; RandomComitteeNumIterations(int) ; ;  addMandatValuedParam(o, '-I', int) -> getWekaRandomComitteeConfig1(o)
wekaRandomComitteeOptsSeed				; getWekaRandomComitteeConfig1(o);	o; ; ; addMandatValuedParam(o, '-S', '1')
# -W <base> mandatory: see global method at beginning of META CLASSIFIERS section

# Random Subspace
wekaRandomSubspace; wekaCreateMetaClassifier(c); c,oList,cnLocal,oArray; ; ; weka.classifiers.meta.RandomSubSpace:__construct(c) -> wekaSelectBaseClassifier(cnLocal) -> getOptionList(oList) -> getWekaRandomSubspaceConfig0(oList) -> getWekaGivenBaseConfig(cnLocal,oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.RandomSubSpace:setOptions(c,oArray)
# -I <int> mandatory
wekaRandomSubspaceOptsNumIterations		; getWekaRandomSubspaceConfig0(o);	o,int; RandomSubspaceNumIterations(int) ; ; addMandatValuedParam(o, '-I', int) -> getWekaRandomSubspaceConfig1(o)
# -P <float> mandatory
wekaRandomSubspaceOptsSubSpaceSize		; getWekaRandomSubspaceConfig1(o);	o,float; RandomSubspaceSubSpaceSizePercent(float) ; ; addMandatValuedParam(o, '-P', float) -> getWekaRandomSubspaceConfig2(o)
# -S 1  mandatory
wekaRandomSubspaceOptsSeed				; getWekaRandomSubspaceConfig2(o);	o; ; ; addMandatValuedParam(o, '-S', '1')
# -W <base> mandatory: see global method at beginning of META CLASSIFIERS section


### ENSEMBLE CLASSIFIERS ###

# Voting
wekaVote;	wekaCreateEnsembleClassifier(c); c,oList,oArray; ; ; weka.classifiers.meta.Vote:__construct(c) -> getOptionList(oList) -> getWekaVoteConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.Vote:setOptions(c,oArray)
# -R <proc>, -S 1  mandatory
wekaVoteOptsCombinationRule	; getWekaVoteConfig0(o);	o,proc; VoteCombinationRule(proc) ; ; addMandatValuedParam(o, '-R', proc) -> getWekaVoteConfig1(o)
wekaVoteOptsSeed			; getWekaVoteConfig1(o);	o; ; ; addMandatValuedParam(o, '-S', '1') -> getWekaVoteConfig2(o)
# -B <base> mandatory
wekaVoteBaseClassifier	; getWekaVoteConfig2(o);	o; ; ; getWekaVoteConfig3(o)
wekaVoteBaseClassifier	; getWekaVoteConfig2(o);	o; ; ; getWekaVoteConfig4(o)
wekaVoteBaseClassifier	; getWekaVoteConfig2(o);	o; ; ; getWekaVoteConfig5(o)
wekaVoteBaseClassifier	; getWekaVoteConfig2(o);	o; ; ; getWekaVoteConfig6(o)
wekaVoteBaseClassifier	; getWekaVoteConfig2(o);	o; ; ; getWekaVoteConfig7(o)
wekaVoteBaseClassifier	; getWekaVoteConfig3(o);	o,cnLocal,oLocal,val; ; ; getOptionList(oLocal) -> wekaParametrizeBaseClassifier(cnLocal, oLocal) -> concatenateWithName(cnLocal, oLocal, val) -> addMandatValuedParam(o, '-B', val) -> getWekaVoteConfig4(o)
wekaVoteBaseClassifier	; getWekaVoteConfig4(o);	o,cnLocal,oLocal,val; ; ; getOptionList(oLocal) -> wekaParametrizeBaseClassifier(cnLocal, oLocal) -> concatenateWithName(cnLocal, oLocal, val) -> addMandatValuedParam(o, '-B', val) -> getWekaVoteConfig5(o)
wekaVoteBaseClassifier	; getWekaVoteConfig5(o);	o,cnLocal,oLocal,val; ; ; getOptionList(oLocal) -> wekaParametrizeBaseClassifier(cnLocal, oLocal) -> concatenateWithName(cnLocal, oLocal, val) -> addMandatValuedParam(o, '-B', val) -> getWekaVoteConfig6(o)
wekaVoteBaseClassifier	; getWekaVoteConfig6(o);	o,cnLocal,oLocal,val; ; ; getOptionList(oLocal) -> wekaParametrizeBaseClassifier(cnLocal, oLocal) -> concatenateWithName(cnLocal, oLocal, val) -> addMandatValuedParam(o, '-B', val) -> getWekaVoteConfig7(o)
wekaVoteBaseClassifier	; getWekaVoteConfig7(o);	o,cnLocal,oLocal,val; ; ; getOptionList(oLocal) -> wekaParametrizeBaseClassifier(cnLocal, oLocal) -> concatenateWithName(cnLocal, oLocal, val) -> addMandatValuedParam(o, '-B', val)

# Stacking
wekaStacking;	wekaCreateEnsembleClassifier(c); c,oList,oArray; ; ; weka.classifiers.meta.Stacking:__construct(c) -> getOptionList(oList) -> getWekaStackingConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.Stacking:setOptions(c,oArray)
# -X 10, -S 1  mandatory
wekaStackingOptsNumFolds	; getWekaStackingConfig0(o);	o; ; ; addMandatValuedParam(o, '-X', '10') -> getWekaStackingConfig1(o)
wekaStackingOptsSeed		; getWekaStackingConfig1(o);	o; ; ; addMandatValuedParam(o, '-S', '1') -> getWekaStackingConfig2(o)
# -B <base> mandatory
wekaStackingBaseClassifier	; getWekaStackingConfig2(o);	o; ; ; getWekaStackingConfig3(o)
wekaStackingBaseClassifier	; getWekaStackingConfig2(o);	o; ; ; getWekaStackingConfig4(o)
wekaStackingBaseClassifier	; getWekaStackingConfig2(o);	o; ; ; getWekaStackingConfig5(o)
wekaStackingBaseClassifier	; getWekaStackingConfig2(o);	o; ; ; getWekaStackingConfig6(o)
wekaStackingBaseClassifier	; getWekaStackingConfig2(o);	o; ; ; getWekaStackingConfig7(o)
wekaStackingBaseClassifier	; getWekaStackingConfig3(o);	o,cnLocal,oLocal,val; ; ; getOptionList(oLocal) -> wekaParametrizeBaseClassifier(cnLocal, oLocal) -> concatenateWithName(cnLocal, oLocal, val) -> addMandatValuedParam(o, '-B', val) -> getWekaStackingConfig4(o)
wekaStackingBaseClassifier	; getWekaStackingConfig4(o);	o,cnLocal,oLocal,val; ; ; getOptionList(oLocal) -> wekaParametrizeBaseClassifier(cnLocal, oLocal) -> concatenateWithName(cnLocal, oLocal, val) -> addMandatValuedParam(o, '-B', val) -> getWekaStackingConfig5(o)
wekaStackingBaseClassifier	; getWekaStackingConfig5(o);	o,cnLocal,oLocal,val; ; ; getOptionList(oLocal) -> wekaParametrizeBaseClassifier(cnLocal, oLocal) -> concatenateWithName(cnLocal, oLocal, val) -> addMandatValuedParam(o, '-B', val) -> getWekaStackingConfig6(o)
wekaStackingBaseClassifier	; getWekaStackingConfig6(o);	o,cnLocal,oLocal,val; ; ; getOptionList(oLocal) -> wekaParametrizeBaseClassifier(cnLocal, oLocal) -> concatenateWithName(cnLocal, oLocal, val) -> addMandatValuedParam(o, '-B', val) -> getWekaStackingConfig7(o)
wekaStackingBaseClassifier	; getWekaStackingConfig7(o);	o,cnLocal,oLocal,val; ; ; getOptionList(oLocal) -> wekaParametrizeBaseClassifier(cnLocal, oLocal) -> concatenateWithName(cnLocal, oLocal, val) -> addMandatValuedParam(o, '-B', val)


## VALIDATION ##
####### simpleValidation; validate(c,x,f,r,quality); c,x,split,train,test,f,r,e,quality; Classifier(c) & Instances(test); split(x,split) -> retrieveTrain(split,train) -> weka.classifiers.Classifier:buildClassifier(c,train) -> weka.classifiers.evaluation.Evaluation:__construct(train,e) -> retrieveTest(split,test) -> weka.classifiers.evaluation.Evaluation:evaluateModel(e,c,test) -> weka.classifiers.evaluation.Evaluation:pctCorrect(e,quality)
####### crossValidation; validate(c,x,f,r,quality); c,x,f,r,e,quality; Classifier(c) & Instances(x) & Folds(f) & Random(r); weka.classifiers.evaluation.Evaluation:__construct(x,e) -> weka.classifiers.evaluation.Evaluation:crossValidateModel(e, c, x, f, r) -> weka.classifiers.evaluation.Evaluation:pctCorrect(e,quality)